<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF åœ°åœ–é…æº–å·¥å…· (V9: ç©©å®šåŒ¯å‡ºç‰ˆ)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        body { margin: 0; padding: 0; display: flex; height: 100vh; font-family: "Microsoft JhengHei", sans-serif; overflow: hidden; }
        
        .sidebar { 
            width: 340px; background: #f8f9fa; padding: 15px; 
            display: flex; flex-direction: column; overflow-y: auto; z-index: 1000; 
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); 
            transition: transform 0.3s ease; position: relative;
        }
        .sidebar.collapsed { transform: translateX(-340px); margin-right: -340px; }
        
        .toggle-btn {
            position: absolute; top: 10px; right: -40px;
            width: 40px; height: 40px; background: #007bff; color: white;
            border: none; border-radius: 0 5px 5px 0; cursor: pointer;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2); z-index: 2000;
        }

        .section { margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; background: white; border-radius: 5px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        button { width: 100%; padding: 8px; margin-top: 5px; cursor: pointer; border: none; border-radius: 3px; color: white; background: #6c757d; }
        button:hover { opacity: 0.9; }
        button.primary { background: #007bff; }
        button.success { background: #28a745; }
        button.warning { background: #ffc107; color: #333; }
        button.info { background: #17a2b8; }
        button.active { background: #0056b3; border: 2px solid #000; }
        
        #map { flex: 1; height: 100%; z-index: 0; cursor: crosshair; }
        
        .handle-icon { background: rgba(255, 255, 255, 0.9); border: 2px solid #333; border-radius: 50%; cursor: nwse-resize; }
        .move-handle-icon { background: rgba(0, 123, 255, 0.9); border: 2px solid white; border-radius: 4px; color: white; text-align: center; font-size: 16px; line-height: 18px; cursor: move; }

        .status-msg { font-size: 12px; color: #d63384; margin-top: 5px; font-weight: bold; line-height: 1.4; }
        .lock-control { display: flex; align-items: center; margin-top: 10px; background: #e9ecef; padding: 5px; border-radius: 4px; }
        .lock-control input { margin-right: 8px; transform: scale(1.2); }
        .scale-inputs { display: flex; gap: 10px; margin-top: 5px; }
        .scale-inputs div { flex: 1; }
        .scale-inputs input { width: 100%; padding: 4px; font-size: 12px; }
        
        .draw-tools { display: flex; gap: 5px; flex-wrap: wrap; }
        .draw-tools button { flex: 1; min-width: 60px; font-size: 12px; }
        
        #debug-info { font-family: monospace; font-size: 11px; background: #333; color: #0f0; padding: 8px; margin-top: 10px; border-radius: 4px; display: none; word-break: break-all; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
    <h3>âš¡ å°é›»åœ–è™Ÿé…æº–å·¥å…· V9</h3>

    <div class="section">
        <label>1. ä¸Šå‚³ PDF</label>
        <input type="file" id="pdf-input" accept="application/pdf">
        <div id="auto-detect-msg" class="status-msg"></div>
        
        <label style="margin-top:10px">ç™½é‚Šæ“´å……ä¿‚æ•¸:</label>
        <div class="scale-inputs">
            <div><label style="font-size:11px; margin:0;">â†”ï¸ å¯¬åº¦å€ç‡</label><input type="number" id="scale-x" value="1.24" step="0.01" onchange="recalcBounds()"></div>
            <div><label style="font-size:11px; margin:0;">â†•ï¸ é«˜åº¦å€ç‡</label><input type="number" id="scale-y" value="1.42" step="0.01" onchange="recalcBounds()"></div>
        </div>

        <label style="margin-top:10px">é€æ˜åº¦:</label>
        <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="0.6" style="width:100%">

        <div class="lock-control">
            <input type="checkbox" id="aspect-ratio-check" checked>
            <label for="aspect-ratio-check" style="margin:0; cursor:pointer;">ğŸ”’ é–å®šé•·å¯¬æ¯”</label>
        </div>
        <button id="btn-lock" class="warning" onclick="toggleLock()" disabled>ğŸ”“ é–å®š / è§£é– PDF</button>
        <button class="info" onclick="showBoundsInfo()">ğŸ“‹ é¡¯ç¤ºé‚Šç•Œæ•¸æ“š</button>
        <div id="debug-info"></div>
    </div>
    
    <div class="section" style="border-left: 4px solid #6610f2;">
        <label>2. ç¹ªåœ–è¨»è¨˜ (Draw)</label>
        <div class="draw-tools">
            <button onclick="setDrawMode('circle')" id="btn-draw-circle">â­• ç•«åœ“</button>
            <button onclick="setDrawMode('line')" id="btn-draw-line">â– ç•«ç·š</button>
            <button onclick="setDrawMode('text')" id="btn-draw-text">Aa æ–‡å­—</button>
            <button onclick="setDrawMode(null)" id="btn-draw-cancel" style="background:#ddd; color:#333;">âœ‹ åœæ­¢</button>
        </div>
        <div style="font-size:11px; color:#666; margin-top:5px;">
            * ç•«åœ“: æ‹–æ‹‰åŠå¾‘<br>
            * ç•«ç·š: æ‹–æ‹‰èµ·çµ‚é»<br>
            * æ–‡å­—: é»æ“Šåœ°åœ–è¼¸å…¥
        </div>
        <button onclick="clearDrawings()" style="background:#dc3545; margin-top:5px;">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰ç¹ªåœ–</button>
    </div>

    <div class="section" style="border-left: 4px solid #28a745;">
        <label>3. åƒè€ƒ G-Code (CSV)</label>
        <input type="file" id="ref-csv-input" accept=".csv">
        <div style="margin-top:5px;">
            <select id="csv-encoding" style="font-size:12px;">
                <option value="UTF-8">UTF-8</option>
                <option value="Big5">Big5</option>
            </select>
            <button onclick="clearRefMarkers()" style="width:auto; float:right; padding:2px 8px; font-size:12px; background:#6c757d;">æ¸…é™¤</button>
        </div>
        <div id="ref-status" style="font-size:12px; color:#28a745; margin-top:5px;"></div>
    </div>

    <div class="section">
        <label>4. æ¨™è¨»è³‡æ–™ (ç´…é»)</label>
        <textarea id="json-input" placeholder='[{"lat": 25.033, "lng": 121.565, "name": "é»1", "category": "ä¸€èˆ¬"}]' style="width:100%; height:60px"></textarea>
        <button class="primary" onclick="importData()">åŒ¯å…¥æ¨™è¨» JSON</button>
        <button onclick="addManualMarker()">â• æ–°å¢æ¨™è¨»é»</button>
        <button onclick="clearMarkers()" style="background:#dc3545">æ¸…é™¤æ‰€æœ‰æ¨™è¨»</button>
    </div>

    <div class="section">
        <button class="success" onclick="exportPDF()">ğŸ’¾ åŒ¯å‡º PDF</button>
        <button class="primary" onclick="saveProject()">ğŸ“‚ å„²å­˜å°ˆæ¡ˆ (JSON)</button>
        <button onclick="loadProjectClick()">ğŸ“‚ è¼‰å…¥å°ˆæ¡ˆ (JSON)</button>
        <input type="file" id="project-input" accept=".json" style="display: none;">
    </div>
</div>

<div id="map"></div>

<script>
    // --- åˆå§‹è¨­å®š ---
    proj4.defs("EPSG:3828", "+proj=tmerc +lat_0=0 +lon_0=121 +x_0=250000 +y_0=0 +k=0.9999 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");

    const taiGridMap = {
        'A': [170000, 2750000], 'B': [250000, 2750000], 'C': [330000, 2750000],
        'D': [170000, 2700000], 'E': [250000, 2700000], 'F': [330000, 2700000],
        'G': [170000, 2650000], 'H': [250000, 2650000], 'J': [90000, 2600000],
        'K': [170000, 2600000], 'L': [250000, 2600000], 'M': [90000, 2550000],
        'N': [170000, 2550000], 'O': [250000, 2550000], 'P': [90000, 2500000],
        'Q': [170000, 2500000], 'R': [250000, 2500000], 'T': [170000, 2450000],
        'U': [250000, 2450000], 'V': [170000, 2400000], 'W': [250000, 2400000],
        'X': [275000, 2614000], 'Y': [275000, 2564000]
    };

    const EXACT_BOUNDS = { "G5050": [[24.183209, 120.613454], [24.176813, 120.623288]] };

    let map = L.map('map', { maxZoom: 25 }).setView([24.1800, 120.6200], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 25, maxNativeZoom: 19 }).addTo(map);
    
    let pdfOverlay = null;
    let pdfDocBytes = null;
    let boundsHandleNW, boundsHandleSE, boundsHandleCenter;
    let isLocked = false;
    let markersData = [];
    let refMarkersLayer = L.layerGroup().addTo(map);
    let drawnItemsLayer = L.layerGroup().addTo(map);
    let currentBaseBounds = null;
    let currentDrawMode = null;
    let tempDrawShape = null;

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    function toggleSidebar() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => { map.invalidateSize(); }, 300);
    }

    // --- PDF ä¸Šå‚³èˆ‡è¤‡è£½ ---
    document.getElementById('pdf-input').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (!file) return;

        // æ·±å±¤è¤‡è£½ Bufferï¼Œé¿å…è¢« Worker è½‰ç§»
        const rawBuffer = await file.arrayBuffer();
        pdfDocBytes = rawBuffer.slice(0);
        const displayBuffer = rawBuffer.slice(0);
        
        const gridInfo = getGridBounds(file.name);
        const msgDiv = document.getElementById('auto-detect-msg');
        let initialBounds;

        if (gridInfo) {
            if(gridInfo.type === 'exact') {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (ç²¾æº–)`;
                initialBounds = gridInfo.bounds;
                currentBaseBounds = null;
            } else {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (è‡ªå‹•ç™½é‚Š)`;
                currentBaseBounds = gridInfo.bounds;
                initialBounds = applyScale(gridInfo.bounds);
            }
        } else {
            msgDiv.innerText = `âš ï¸ æœªåµæ¸¬åˆ°åœ–è™Ÿ`;
            currentBaseBounds = null;
        }

        const loadingTask = pdfjsLib.getDocument(displayBuffer);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 4 }); // 4K æ¸²æŸ“
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const imgUrl = canvas.toDataURL('image/png');

        if (!initialBounds) {
            const c = map.getCenter();
            const latRad = c.lat * Math.PI / 180;
            const hDeg = 0.005; 
            const wDeg = hDeg * (viewport.width / viewport.height) / Math.cos(latRad); 
            initialBounds = [[c.lat + hDeg/2, c.lng - wDeg/2], [c.lat - hDeg/2, c.lng + wDeg/2]];
        }

        if (pdfOverlay) map.removeLayer(pdfOverlay);
        clearControlHandles();
        pdfOverlay = L.imageOverlay(imgUrl, initialBounds, { opacity: 0.6 }).addTo(map);
        createControlHandles(initialBounds);
        document.getElementById('btn-lock').disabled = false;
        map.fitBounds(initialBounds);
    });

    function getGridBounds(filename) {
        const simpleName = filename.split('/').pop().split('.')[0].toUpperCase();
        if (EXACT_BOUNDS[simpleName]) return { type: 'exact', bounds: EXACT_BOUNDS[simpleName] };
        const match = simpleName.match(/([A-Z])(\d{2})(\d{2})/);
        if (!match) return null;
        const code = match[1], xIdx = parseInt(match[2]), yIdx = parseInt(match[3]);
        const base = taiGridMap[code];
        if (!base) return null;
        const startX = base[0] + (xIdx * 800), startY = base[1] + (yIdx * 500);
        const endX = startX + 800, endY = startY + 500;
        const p1 = proj4("EPSG:3828", "EPSG:4326", [startX, startY]);
        const p2 = proj4("EPSG:3828", "EPSG:4326", [endX, endY]);
        return { type: 'grid', bounds: [[p2[1], p1[0]], [p1[1], p2[0]]] };
    }

    function applyScale(gridBounds) {
        const scaleX = parseFloat(document.getElementById('scale-x').value) || 1.0;
        const scaleY = parseFloat(document.getElementById('scale-y').value) || 1.0;
        const N = gridBounds[0][0], W = gridBounds[0][1];
        const S = gridBounds[1][0], E = gridBounds[1][1];
        const cLat = (N + S) / 2, cLng = (W + E) / 2;
        const h = N - S, w = E - W;
        return [[cLat + (h*scaleY)/2, cLng - (w*scaleX)/2], [cLat - (h*scaleY)/2, cLng + (w*scaleX)/2]];
    }

    window.recalcBounds = function() {
        if (!currentBaseBounds || !pdfOverlay) return;
        const newBounds = applyScale(currentBaseBounds);
        pdfOverlay.setBounds(newBounds);
        clearControlHandles();
        createControlHandles(newBounds);
    };

    function clearControlHandles() {
        if (boundsHandleNW) map.removeLayer(boundsHandleNW);
        if (boundsHandleSE) map.removeLayer(boundsHandleSE);
        if (boundsHandleCenter) map.removeLayer(boundsHandleCenter);
    }
    function createControlHandles(bounds) {
        const icon = L.divIcon({ className: 'handle-icon', iconSize: [12, 12] });
        const centerIcon = L.divIcon({ className: 'move-handle-icon', html: '+', iconSize: [20, 20], iconAnchor: [10, 10] });
        
        boundsHandleNW = L.marker(bounds[0], { draggable: true, icon: icon }).addTo(map);
        boundsHandleSE = L.marker(bounds[1], { draggable: true, icon: icon }).addTo(map);
        const center = L.latLngBounds(bounds).getCenter();
        boundsHandleCenter = L.marker(center, { draggable: true, icon: centerIcon, zIndexOffset: 1000 }).addTo(map);

        const handleResize = (e) => {
            const isRatioLocked = document.getElementById('aspect-ratio-check').checked;
            const target = e.target;
            const isNW = (target === boundsHandleNW);
            let anchor = isNW ? boundsHandleSE.getLatLng() : boundsHandleNW.getLatLng();
            let current = target.getLatLng();
            if (isRatioLocked) {
                const oldB = pdfOverlay.getBounds();
                const oNW = oldB.getNorthWest(), oSE = oldB.getSouthEast();
                const ratio = (isNW ? (oNW.lng - oSE.lng) : (oSE.lng - oNW.lng)) / (isNW ? (oNW.lat - oSE.lat) : (oSE.lat - oNW.lat));
                current.lng = anchor.lng + (current.lat - anchor.lat) * ratio;
                target.setLatLng(current);
            }
            let newNW = isNW ? current : anchor, newSE = isNW ? anchor : current;
            pdfOverlay.setBounds([newNW, newSE]);
            boundsHandleCenter.setLatLng(L.latLngBounds([newNW, newSE]).getCenter());
        };
        const handleMove = (e) => {
            const newCenter = e.target.getLatLng();
            const oldCenter = pdfOverlay.getBounds().getCenter();
            const dLat = newCenter.lat - oldCenter.lat, dLng = newCenter.lng - oldCenter.lng;
            const b = pdfOverlay.getBounds();
            pdfOverlay.setBounds([[b.getNorth()+dLat, b.getWest()+dLng], [b.getSouth()+dLat, b.getEast()+dLng]]);
            boundsHandleNW.setLatLng([b.getNorth()+dLat, b.getWest()+dLng]);
            boundsHandleSE.setLatLng([b.getSouth()+dLat, b.getEast()+dLng]);
        };
        boundsHandleNW.on('drag', handleResize);
        boundsHandleSE.on('drag', handleResize);
        boundsHandleCenter.on('drag', handleMove);
    }
    function toggleLock() {
        if (!pdfOverlay) return;
        isLocked = !isLocked;
        const btn = document.getElementById('btn-lock');
        if (isLocked) {
            clearControlHandles();
            pdfOverlay.getElement().style.pointerEvents = 'none';
            btn.innerText = 'ğŸ”’ å·²é–å®š'; btn.className = 'success';
        } else {
            const b = pdfOverlay.getBounds();
            createControlHandles([b.getNorthWest(), b.getSouthEast()]);
            pdfOverlay.getElement().style.pointerEvents = 'auto';
            btn.innerText = 'ğŸ”“ é–å®š / è§£é–'; btn.className = 'warning';
        }
    }
    document.getElementById('opacity-slider').addEventListener('input', e => { if(pdfOverlay) pdfOverlay.setOpacity(e.target.value); });
    function showBoundsInfo() { if(pdfOverlay) alert(pdfOverlay.getBounds().toBBoxString()); }

    // --- ç¹ªåœ–å·¥å…· ---
    window.setDrawMode = function(mode) {
        currentDrawMode = mode;
        map.dragging.enable();
        document.querySelectorAll('.draw-tools button').forEach(b => b.classList.remove('active'));
        if(mode) {
            document.getElementById('btn-draw-'+mode).classList.add('active');
            map.dragging.disable(); 
            map.getContainer().style.cursor = 'crosshair';
        } else { map.getContainer().style.cursor = ''; }
    };
    window.clearDrawings = function() { if(confirm("ç¢ºå®šæ¸…é™¤?")) drawnItemsLayer.clearLayers(); };

    let startPoint = null;
    map.on('mousedown', function(e) {
        if(!currentDrawMode) return;
        startPoint = e.latlng;
        if(currentDrawMode === 'circle') tempDrawShape = L.circle(startPoint, {radius: 1, color:'red', weight:2}).addTo(drawnItemsLayer);
        else if(currentDrawMode === 'line') tempDrawShape = L.polyline([startPoint, startPoint], {color:'red', weight:3}).addTo(drawnItemsLayer);
        else if(currentDrawMode === 'text') {
            const text = prompt("è¼¸å…¥æ–‡å­—:", "è¨»è¨˜");
            if(text) {
                const marker = L.marker(startPoint, {
                    icon: L.divIcon({ className: 'text-label', html: `<div style="color:red;font-size:16px;font-weight:bold;text-shadow:1px 1px 0 #fff;">${text}</div>`, iconSize: [100, 20] }),
                    interactive: true, draggable: true
                }).addTo(drawnItemsLayer);
                marker.drawType = 'text'; marker.textContent = text;
            }
            setDrawMode(null);
        }
    });
    map.on('mousemove', function(e) {
        if(!currentDrawMode || !startPoint || !tempDrawShape) return;
        if(currentDrawMode === 'circle') tempDrawShape.setRadius(map.distance(startPoint, e.latlng));
        else if(currentDrawMode === 'line') tempDrawShape.setLatLngs([startPoint, e.latlng]);
    });
    map.on('mouseup', function(e) {
        if(!currentDrawMode || !startPoint) return;
        if(tempDrawShape) tempDrawShape.drawType = currentDrawMode;
        startPoint = null; tempDrawShape = null; setDrawMode(null);
    });

    // --- CSV & Markers ---
    document.getElementById('ref-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('csv-encoding').value;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                results.data.forEach(row => {
                    const lat = parseFloat(row['G-y']), lng = parseFloat(row['G-x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 }).bindPopup(`<b>${row['G-code']}</b><br>${row['G-W']||''}`).addTo(refMarkersLayer);
                        count++;
                    }
                });
                document.getElementById('ref-status').innerText = `âœ… å·²è¼‰å…¥ ${count} å€‹`;
            }
        });
    });
    function clearRefMarkers() { refMarkersLayer.clearLayers(); }
    
    function addMarkerToMap(lat, lng, name, category, id=null) {
        const marker = L.marker([lat, lng], { draggable: true }).addTo(map);
        const dataId = id || Date.now().toString();
        marker.bindPopup(`åç¨±: <input value="${name}" onchange="updateM('${dataId}','name',this.value)"><br>é¡åˆ¥: <select onchange="updateM('${dataId}','category',this.value)"><option value="ä¸€èˆ¬">ä¸€èˆ¬</option><option value="å¾…ä¿®">å¾…ä¿®</option></select><br><button onclick="delM('${dataId}')">åˆªé™¤</button>`);
        markersData.push({ id: dataId, lat, lng, name, category, markerRef: marker });
        marker.on('dragend', e => { const d = markersData.find(x=>x.id===dataId); if(d) { d.lat=e.target.getLatLng().lat; d.lng=e.target.getLatLng().lng; }});
    }
    window.updateM=(id,f,v)=>{const d=markersData.find(x=>x.id===id);if(d)d[f]=v;};
    window.delM=(id)=>{const idx=markersData.findIndex(x=>x.id===id);if(idx>=0){map.removeLayer(markersData[idx].markerRef);markersData.splice(idx,1);}};
    function addManualMarker(){ addMarkerToMap(map.getCenter().lat, map.getCenter().lng, 'æ–°é»', 'ä¸€èˆ¬'); }
    function clearMarkers(){ markersData.forEach(d=>map.removeLayer(d.markerRef)); markersData=[]; }

    // --- åŒ¯å‡º PDF (ä¿®å¾© Annots Array éŒ¯èª¤) ---
    async function exportPDF() {
        if (!pdfDocBytes || !pdfOverlay) return alert("è«‹å…ˆä¸Šå‚³ PDF");
        try {
            const { PDFDocument, PDFHexString } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfDocBytes);
            const page = pdfDoc.getPages()[0];
            const { width: pdfW, height: pdfH } = page.getSize();
            const b = pdfOverlay.getBounds();
            const north = b.getNorth(), south = b.getSouth(), east = b.getEast(), west = b.getWest();

            function toPdfPoint(lat, lng) {
                return { x: ((lng - west)/(east - west))*pdfW, y: ((lat - south)/(north - south))*pdfH };
            }

            // 1. Markers
            for (const p of markersData) {
                if (p.lat > north || p.lat < south || p.lng > east || p.lng < west) continue;
                const pt = toPdfPoint(p.lat, p.lng);
                const text = (p.name||'') + " (" + (p.category||'') + ")";
                const annot = pdfDoc.context.obj({
                    Type: 'Annot', Subtype: 'Square',
                    Rect: [pt.x-5, pt.y-5, pt.x+5, pt.y+5], C: [1, 0, 0], IC: [1, 0, 0],
                    Contents: createPdfHexString(text), T: createPdfHexString(p.category||'Note')
                });
                addAnnot(page, annot, pdfDoc);
            }

            // 2. Drawings
            drawnItemsLayer.eachLayer(layer => {
                if (layer.drawType === 'circle') {
                    const center = layer.getLatLng();
                    const pt = toPdfPoint(center.lat, center.lng);
                    const pdfR = Math.abs(toPdfPoint(center.lat + layer.getRadius()/111111, center.lng).y - pt.y);
                    const annot = pdfDoc.context.obj({
                        Type: 'Annot', Subtype: 'Circle',
                        Rect: [pt.x-pdfR, pt.y-pdfR, pt.x+pdfR, pt.y+pdfR], C: [1, 0, 0], Border: [0, 0, 2],
                        Contents: createPdfHexString("Circle")
                    });
                    addAnnot(page, annot, pdfDoc);
                } else if (layer.drawType === 'line') {
                    const lls = layer.getLatLngs();
                    if(lls.length>=2) {
                        const p1 = toPdfPoint(lls[0].lat, lls[0].lng), p2 = toPdfPoint(lls[1].lat, lls[1].lng);
                        const annot = pdfDoc.context.obj({
                            Type: 'Annot', Subtype: 'Line',
                            Rect: [Math.min(p1.x,p2.x), Math.min(p1.y,p2.y), Math.max(p1.x,p2.x), Math.max(p1.y,p2.y)],
                            L: [p1.x, p1.y, p2.x, p2.y], C: [1, 0, 0], Border: [0, 0, 2]
                        });
                        addAnnot(page, annot, pdfDoc);
                    }
                } else if (layer.drawType === 'text') {
                    const pt = toPdfPoint(layer.getLatLng().lat, layer.getLatLng().lng);
                    const annot = pdfDoc.context.obj({
                        Type: 'Annot', Subtype: 'FreeText',
                        Rect: [pt.x, pt.y, pt.x+100, pt.y+20],
                        Contents: createPdfHexString(layer.textContent||""),
                        DA: PDFLib.PDFString.of("/Helv 12 Tf 1 0 0 rg")
                    });
                    addAnnot(page, annot, pdfDoc);
                }
            });

            const outBytes = await pdfDoc.save();
            const blob = new Blob([outBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'annotated_map.pdf';
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        } catch (err) { console.error(err); alert("åŒ¯å‡ºéŒ¯èª¤ï¼š" + err.message); }
    }

    // é—œéµä¿®æ­£ï¼šå°‡è¨»é‡‹æ­£ç¢ºåŠ å…¥ Annots é™£åˆ—
    function addAnnot(page, annot, pdfDoc) {
        const annotRef = pdfDoc.context.register(annot); // 1. è¨»å†Šç‚º Reference
        let annots = page.node.Annots();
        if (!annots) {
            // 2. è‹¥é™£åˆ—ä¸å­˜åœ¨ï¼Œå»ºç«‹ä¸€å€‹æ–°çš„ PDFArray åŒ…å«è©² Reference
            const annotsArray = pdfDoc.context.obj([annotRef]);
            const annotsRef = pdfDoc.context.register(annotsArray);
            page.node.set(PDFLib.PDFName.of('Annots'), annotsRef);
        } else {
            // 3. è‹¥å·²å­˜åœ¨ï¼Œæ¨å…¥ Reference
            annots.push(annotRef);
        }
    }

    function createPdfHexString(text) {
        if (!text) return PDFLib.PDFHexString.of('FEFF'); 
        let hex = 'FEFF';
        for (let i = 0; i < text.length; i++) {
            let code = text.charCodeAt(i).toString(16).toUpperCase();
            while (code.length < 4) code = '0' + code;
            hex += code;
        }
        return PDFLib.PDFHexString.of(hex);
    }

    // --- å°ˆæ¡ˆå­˜æª” ---
    function saveProject() {
        if(!pdfOverlay) return;
        const b = pdfOverlay.getBounds();
        const data = {
            bounds: { north: b.getNorth(), south: b.getSouth(), east: b.getEast(), west: b.getWest() },
            markers: markersData.map(d => ({ lat:d.lat, lng:d.lng, name:d.name, category:d.category }))
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = 'project.json';
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }
    function loadProjectClick() { document.getElementById('project-input').click(); }
    document.getElementById('project-input').addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            try {
                const d = JSON.parse(evt.target.result);
                if(d.bounds && pdfOverlay) {
                    const b = [[d.bounds.north, d.bounds.west], [d.bounds.south, d.bounds.east]];
                    pdfOverlay.setBounds(b);
                    map.fitBounds(b);
                    if(!isLocked) { clearControlHandles(); createControlHandles(pdfOverlay.getBounds()); }
                }
                if(d.markers) {
                    clearMarkers();
                    d.markers.forEach(p => addMarkerToMap(p.lat, p.lng, p.name, p.category));
                }
            } catch(err) { alert("è®€å–å¤±æ•—"); }
        };
        reader.readAsText(file);
    });
</script>
</body>
</html>
