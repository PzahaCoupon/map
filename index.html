<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF åœ°åœ–é…æº–å·¥å…· (V15: è·¯ç‡ˆç™»è¨˜å–®æ•´åˆç‰ˆ)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.0/proj4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>

    <style>
        body { margin: 0; padding: 0; display: flex; height: 100vh; font-family: "Microsoft JhengHei", sans-serif; overflow: hidden; }
        
        .sidebar { 
            width: 360px; background: #f8f9fa; padding: 15px; 
            display: flex; flex-direction: column; overflow-y: auto; z-index: 1000; 
            box-shadow: 2px 0 5px rgba(0,0,0,0.1); 
            transition: transform 0.3s ease; position: relative;
        }
        .sidebar.collapsed { transform: translateX(-360px); margin-right: -360px; }
        
        .toggle-btn {
            position: absolute; top: 10px; right: -40px;
            width: 40px; height: 40px; background: #007bff; color: white;
            border: none; border-radius: 0 5px 5px 0; cursor: pointer;
            font-size: 20px; display: flex; align-items: center; justify-content: center;
            box-shadow: 2px 0 5px rgba(0,0,0,0.2); z-index: 2000;
        }

        .section { margin-bottom: 20px; border: 1px solid #ddd; padding: 10px; background: white; border-radius: 5px; }
        label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        button { width: 100%; padding: 8px; margin-top: 5px; cursor: pointer; border: none; border-radius: 3px; color: white; background: #6c757d; }
        button:hover { opacity: 0.9; }
        button.primary { background: #007bff; }
        button.success { background: #28a745; }
        button.warning { background: #ffc107; color: #333; }
        button.info { background: #17a2b8; }
        button.danger { background: #dc3545; }
        button.active { background: #0056b3; border: 2px solid #000; }
        
        #map { flex: 1; height: 100%; z-index: 0; cursor: crosshair; }
        
        .handle-icon { background: rgba(255, 255, 255, 0.9); border: 2px solid #333; border-radius: 50%; cursor: nwse-resize; }
        .move-handle-icon { background: rgba(0, 123, 255, 0.9); border: 2px solid white; border-radius: 4px; color: white; text-align: center; font-size: 16px; line-height: 18px; cursor: move; }
        .drag-point-icon { background: #007bff; border: 1px solid white; border-radius: 50%; box-shadow: 0 0 3px rgba(0,0,0,0.5); cursor: move; }

        .status-msg { font-size: 12px; color: #d63384; margin-top: 5px; font-weight: bold; line-height: 1.4; }
        .lock-control { display: flex; align-items: center; margin-top: 10px; background: #e9ecef; padding: 5px; border-radius: 4px; }
        .lock-control input { margin-right: 8px; transform: scale(1.2); }
        .scale-inputs { display: flex; gap: 10px; margin-top: 5px; }
        .scale-inputs div { flex: 1; }
        .scale-inputs input { width: 100%; padding: 4px; font-size: 12px; }
        
        .draw-tools { display: flex; gap: 5px; flex-wrap: wrap; }
        .draw-tools button { flex: 1; min-width: 50px; font-size: 12px; }
        .tool-options { display: flex; align-items: center; gap: 10px; margin-top: 5px; font-size: 12px; background: #eee; padding: 5px; border-radius: 4px; flex-wrap: wrap; }
        
        #debug-info { font-family: monospace; font-size: 11px; background: #333; color: #0f0; padding: 8px; margin-top: 10px; border-radius: 4px; display: none; word-break: break-all; }
        .delete-btn { background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 3px; cursor: pointer; font-size: 12px; }

        /* è·¯ç‡ˆç·¨è¼¯ Popup */
        .sl-popup label { font-size: 12px; margin-bottom: 2px; color: #555; }
        .sl-popup input, .sl-popup select { width: 100%; margin-bottom: 8px; padding: 4px; box-sizing: border-box; }
        .sl-popup button { margin-top: 5px; padding: 4px; font-size: 12px; width: 48%; float: left; margin-right: 2%; }
    </style>
</head>
<body>

<div class="sidebar" id="sidebar">
    <button class="toggle-btn" onclick="toggleSidebar()">â˜°</button>
    <h3>âš¡ å°é›»åœ–è™Ÿé…æº–å·¥å…· V15</h3>

    <div class="section">
        <label>1. ä¸Šå‚³ PDF</label>
        <input type="file" id="pdf-input" accept="application/pdf">
        <div id="auto-detect-msg" class="status-msg"></div>
        <label style="margin-top:10px">ç™½é‚Šæ“´å……ä¿‚æ•¸:</label>
        <div class="scale-inputs">
            <div><label style="font-size:11px; margin:0;">â†”ï¸ å¯¬åº¦å€ç‡</label><input type="number" id="scale-x" value="1.24" step="0.01" onchange="recalcBounds()"></div>
            <div><label style="font-size:11px; margin:0;">â†•ï¸ é«˜åº¦å€ç‡</label><input type="number" id="scale-y" value="1.42" step="0.01" onchange="recalcBounds()"></div>
        </div>
        <label style="margin-top:10px">é€æ˜åº¦:</label>
        <input type="range" id="opacity-slider" min="0" max="1" step="0.1" value="0.6" style="width:100%">
        <div class="lock-control">
            <input type="checkbox" id="aspect-ratio-check" checked>
            <label for="aspect-ratio-check" style="margin:0; cursor:pointer;">ğŸ”’ é–å®šé•·å¯¬æ¯”</label>
        </div>
        <button id="btn-lock" class="warning" onclick="toggleLock()" disabled>ğŸ”“ é–å®š / è§£é– PDF</button>
        <button class="info" onclick="showBoundsInfo()">ğŸ“‹ é¡¯ç¤ºé‚Šç•Œæ•¸æ“š</button>
        <div id="debug-info"></div>
    </div>
    
    <div class="section" style="border-left: 4px solid #007bff;">
        <label>2. åŒ¯å…¥è·¯ç‡ˆè³‡æ–™ (CSV)</label>
        <div style="font-size:11px;color:#666;margin-bottom:5px;">æ¬„ä½: name, x, y, G-code_1st</div>
        <input type="file" id="sl-csv-input" accept=".csv">
        <div style="margin-top:5px;">
            <select id="sl-encoding" style="font-size:12px;"><option value="UTF-8">UTF-8</option><option value="Big5">Big5</option></select>
            <button onclick="clearStreetLights()" style="width:auto; float:right; padding:2px 8px; font-size:12px; background:#dc3545;">æ¸…é™¤</button>
        </div>
        <div id="sl-status" style="font-size:12px; color:#007bff; margin-top:5px;"></div>
        <button class="primary" onclick="exportRegistrationSheet()" style="margin-top:10px;">ğŸ“Š åŒ¯å‡ºç™»è¨˜å–® (Excel CSV)</button>
    </div>

    <div class="section" style="border-left: 4px solid #6610f2;">
        <label>3. æ‰‹å‹•ç¹ªåœ– (Draw)</label>
        <div class="draw-tools">
            <button onclick="setDrawMode('circle')" id="btn-draw-circle">â­• ç•«åœ“</button>
            <button onclick="setDrawMode('line')" id="btn-draw-line">â– ç•«ç·š</button>
            <button onclick="setDrawMode('text')" id="btn-draw-text">Aa æ–‡å­—</button>
            <button onclick="setDrawMode(null)" id="btn-draw-cancel" style="background:#ddd; color:#333;">âœ‹ åœæ­¢</button>
        </div>
        <div class="tool-options">
            <div style="display:flex; align-items:center; gap:5px;">
                <label style="margin:0">é¡è‰²:</label>
                <input type="color" id="input-color" value="#ff0000" style="width:30px; height:25px; padding:0; border:none; cursor:pointer;">
            </div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label style="margin:0">å­—ç´š:</label>
                <input type="number" id="input-font-size" value="16" min="8" max="72" style="width:40px;">
                <span>px</span>
            </div>
        </div>
        <button onclick="clearDrawings()" style="background:#dc3545; margin-top:5px;">ğŸ—‘ï¸ æ¸…é™¤æ‰€æœ‰æ‰‹ç¹ª</button>
    </div>

    <div class="section" style="border-left: 4px solid #28a745;">
        <label>4. åƒè€ƒ G-Code (ç¶ é»)</label>
        <input type="file" id="ref-csv-input" accept=".csv">
        <div style="margin-top:5px;">
            <select id="csv-encoding" style="font-size:12px;"><option value="UTF-8">UTF-8</option><option value="Big5">Big5</option></select>
            <button onclick="clearRefMarkers()" style="width:auto; float:right; padding:2px 8px; font-size:12px; background:#6c757d;">æ¸…é™¤</button>
        </div>
        <div id="ref-status" style="font-size:12px; color:#28a745; margin-top:5px;"></div>
    </div>

    <div class="section">
        <button class="success" onclick="exportPDF()">ğŸ’¾ åŒ¯å‡ºåœ–å±¤ PDF</button>
        <button class="primary" onclick="saveProject()">ğŸ“‚ å„²å­˜å°ˆæ¡ˆ (JSON)</button>
        <button onclick="loadProjectClick()">ğŸ“‚ è¼‰å…¥å°ˆæ¡ˆ (JSON)</button>
        <input type="file" id="project-input" accept=".json" style="display: none;">
    </div>
</div>

<div id="map"></div>
<canvas id="text-helper-canvas" style="display:none;"></canvas>

<datalist id="list-old-cap">
    <option value="73W">
    <option value="112W">
    <option value="220W">
    <option value="250W">
</datalist>
<datalist id="list-new-cap">
    <option value="73VA">
    <option value="88VA">
</datalist>

<script>
    // --- Init ---
    proj4.defs("EPSG:3828", "+proj=tmerc +lat_0=0 +lon_0=121 +x_0=250000 +y_0=0 +k=0.9999 +ellps=aust_SA +towgs84=-752,-358,-179,-.0000011698,.0000018398,.0000009822,.00002329 +units=m +no_defs");
    proj4.defs("EPSG:4326", "+proj=longlat +datum=WGS84 +no_defs");
    const taiGridMap = {'A': [170000, 2750000], 'B': [250000, 2750000], 'C': [330000, 2750000], 'D': [170000, 2700000], 'E': [250000, 2700000], 'F': [330000, 2700000], 'G': [170000, 2650000], 'H': [250000, 2650000], 'J': [90000, 2600000], 'K': [170000, 2600000], 'L': [250000, 2600000], 'M': [90000, 2550000], 'N': [170000, 2550000], 'O': [250000, 2550000], 'P': [90000, 2500000], 'Q': [170000, 2500000], 'R': [250000, 2500000], 'T': [170000, 2450000], 'U': [250000, 2450000], 'V': [170000, 2400000], 'W': [250000, 2400000], 'X': [275000, 2614000], 'Y': [275000, 2564000]};
    const EXACT_BOUNDS = { "G5050": [[24.183209, 120.613454], [24.176813, 120.623288]] };

    let map = L.map('map', { maxZoom: 25 }).setView([24.1800, 120.6200], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OSM', maxZoom: 25, maxNativeZoom: 19 }).addTo(map);
    
    let pdfOverlay = null;
    let pdfDocBytes = null;
    let currentPdfName = "map"; // å„²å­˜æª”åç”¨
    let boundsHandleNW, boundsHandleSE, boundsHandleCenter;
    let isLocked = false;
    let refMarkersLayer = L.layerGroup().addTo(map);
    let drawnItemsLayer = L.layerGroup().addTo(map);
    let streetLightsLayer = L.layerGroup().addTo(map); // V15: è·¯ç‡ˆå°ˆç”¨å±¤
    let streetLightsData = []; // å„²å­˜è·¯ç‡ˆè³‡æ–™ç‰©ä»¶
    let currentBaseBounds = null;
    let currentDrawMode = null;
    let tempDrawShape = null;

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    function toggleSidebar() {
        document.getElementById('sidebar').classList.toggle('collapsed');
        setTimeout(() => { map.invalidateSize(); }, 300);
    }

    // --- Helper: Timestamp Name ---
    function getTimestampedName(baseName, ext) {
        const now = new Date();
        const yyyy = now.getFullYear();
        const mm = String(now.getMonth() + 1).padStart(2, '0');
        const dd = String(now.getDate()).padStart(2, '0');
        const HH = String(now.getHours()).padStart(2, '0');
        const MM = String(now.getMinutes()).padStart(2, '0');
        const SS = String(now.getSeconds()).padStart(2, '0');
        return `${baseName}_${yyyy}${mm}${dd}_${HH}${MM}${SS}.${ext}`;
    }

    // --- PDF Logic ---
    document.getElementById('pdf-input').addEventListener('change', async function(e) {
        const file = e.target.files[0];
        if (!file) return;
        currentPdfName = file.name.replace(/\.[^/.]+$/, ""); // å»é™¤å‰¯æª”å
        const rawBuffer = await file.arrayBuffer();
        pdfDocBytes = rawBuffer.slice(0);
        const displayBuffer = rawBuffer.slice(0);
        
        const gridInfo = getGridBounds(file.name);
        const msgDiv = document.getElementById('auto-detect-msg');
        let initialBounds;

        if (gridInfo) {
            if(gridInfo.type === 'exact') {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (ç²¾æº–)`;
                initialBounds = gridInfo.bounds;
                currentBaseBounds = null;
            } else {
                msgDiv.innerHTML = `âœ… ${file.name.substring(0,5)} (è‡ªå‹•ç™½é‚Š)`;
                currentBaseBounds = gridInfo.bounds;
                initialBounds = applyScale(gridInfo.bounds);
            }
        } else {
            msgDiv.innerText = `âš ï¸ æœªåµæ¸¬åˆ°åœ–è™Ÿ`;
            currentBaseBounds = null;
        }

        const loadingTask = pdfjsLib.getDocument(displayBuffer);
        const pdf = await loadingTask.promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale: 4 }); 
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        const imgUrl = canvas.toDataURL('image/png');

        if (!initialBounds) {
            const c = map.getCenter();
            const latRad = c.lat * Math.PI / 180;
            const hDeg = 0.005; 
            const wDeg = hDeg * (viewport.width / viewport.height) / Math.cos(latRad); 
            initialBounds = [[c.lat + hDeg/2, c.lng - wDeg/2], [c.lat - hDeg/2, c.lng + wDeg/2]];
        }

        if (pdfOverlay) map.removeLayer(pdfOverlay);
        clearControlHandles();
        pdfOverlay = L.imageOverlay(imgUrl, initialBounds, { opacity: 0.6 }).addTo(map);
        createControlHandles(initialBounds);
        document.getElementById('btn-lock').disabled = false;
        map.fitBounds(initialBounds);
    });

    function getGridBounds(filename) {
        const simpleName = filename.split('/').pop().split('.')[0].toUpperCase();
        if (EXACT_BOUNDS[simpleName]) return { type: 'exact', bounds: EXACT_BOUNDS[simpleName] };
        const match = simpleName.match(/([A-Z])(\d{2})(\d{2})/);
        if (!match) return null;
        const code = match[1], xIdx = parseInt(match[2]), yIdx = parseInt(match[3]);
        const base = taiGridMap[code];
        if (!base) return null;
        const startX = base[0] + (xIdx * 800), startY = base[1] + (yIdx * 500);
        const endX = startX + 800, endY = startY + 500;
        const p1 = proj4("EPSG:3828", "EPSG:4326", [startX, startY]);
        const p2 = proj4("EPSG:3828", "EPSG:4326", [endX, endY]);
        return { type: 'grid', bounds: [[p2[1], p1[0]], [p1[1], p2[0]]] };
    }

    function applyScale(gridBounds) {
        const scaleX = parseFloat(document.getElementById('scale-x').value) || 1.0;
        const scaleY = parseFloat(document.getElementById('scale-y').value) || 1.0;
        const N = gridBounds[0][0], W = gridBounds[0][1];
        const S = gridBounds[1][0], E = gridBounds[1][1];
        const cLat = (N + S) / 2, cLng = (W + E) / 2;
        const h = N - S, w = E - W;
        return [[cLat + (h*scaleY)/2, cLng - (w*scaleX)/2], [cLat - (h*scaleY)/2, cLng + (w*scaleX)/2]];
    }

    window.recalcBounds = function() {
        if (!currentBaseBounds || !pdfOverlay) return;
        const newBounds = applyScale(currentBaseBounds);
        pdfOverlay.setBounds(newBounds);
        clearControlHandles();
        createControlHandles(newBounds);
    };

    function clearControlHandles() {
        if (boundsHandleNW) map.removeLayer(boundsHandleNW);
        if (boundsHandleSE) map.removeLayer(boundsHandleSE);
        if (boundsHandleCenter) map.removeLayer(boundsHandleCenter);
    }
    function createControlHandles(bounds) {
        const icon = L.divIcon({ className: 'handle-icon', iconSize: [12, 12] });
        const centerIcon = L.divIcon({ className: 'move-handle-icon', html: '+', iconSize: [20, 20], iconAnchor: [10, 10] });
        boundsHandleNW = L.marker(bounds[0], { draggable: true, icon: icon }).addTo(map);
        boundsHandleSE = L.marker(bounds[1], { draggable: true, icon: icon }).addTo(map);
        const center = L.latLngBounds(bounds).getCenter();
        boundsHandleCenter = L.marker(center, { draggable: true, icon: centerIcon, zIndexOffset: 1000 }).addTo(map);

        const handleResize = (e) => {
            const isRatioLocked = document.getElementById('aspect-ratio-check').checked;
            const target = e.target;
            const isNW = (target === boundsHandleNW);
            let anchor = isNW ? boundsHandleSE.getLatLng() : boundsHandleNW.getLatLng();
            let current = target.getLatLng();
            if (isRatioLocked) {
                const oldB = pdfOverlay.getBounds();
                const oNW = oldB.getNorthWest(), oSE = oldB.getSouthEast();
                const ratio = (isNW ? (oNW.lng - oSE.lng) : (oSE.lng - oNW.lng)) / (isNW ? (oNW.lat - oSE.lat) : (oSE.lat - oNW.lat));
                current.lng = anchor.lng + (current.lat - anchor.lat) * ratio;
                target.setLatLng(current);
            }
            let newNW = isNW ? current : anchor, newSE = isNW ? anchor : current;
            pdfOverlay.setBounds([newNW, newSE]);
            boundsHandleCenter.setLatLng(L.latLngBounds([newNW, newSE]).getCenter());
        };
        const handleMove = (e) => {
            const newCenter = e.target.getLatLng();
            const oldCenter = pdfOverlay.getBounds().getCenter();
            const dLat = newCenter.lat - oldCenter.lat, dLng = newCenter.lng - oldCenter.lng;
            const b = pdfOverlay.getBounds();
            pdfOverlay.setBounds([[b.getNorth()+dLat, b.getWest()+dLng], [b.getSouth()+dLat, b.getEast()+dLng]]);
            boundsHandleNW.setLatLng([b.getNorth()+dLat, b.getWest()+dLng]);
            boundsHandleSE.setLatLng([b.getSouth()+dLat, b.getEast()+dLng]);
        };
        boundsHandleNW.on('drag', handleResize);
        boundsHandleSE.on('drag', handleResize);
        boundsHandleCenter.on('drag', handleMove);
    }
    function toggleLock() {
        if (!pdfOverlay) return;
        isLocked = !isLocked;
        const btn = document.getElementById('btn-lock');
        if (isLocked) {
            clearControlHandles();
            pdfOverlay.getElement().style.pointerEvents = 'none';
            btn.innerText = 'ğŸ”’ å·²é–å®š'; btn.className = 'success';
        } else {
            const b = pdfOverlay.getBounds();
            createControlHandles([b.getNorthWest(), b.getSouthEast()]);
            pdfOverlay.getElement().style.pointerEvents = 'auto';
            btn.innerText = 'ğŸ”“ é–å®š / è§£é–'; btn.className = 'warning';
        }
    }
    document.getElementById('opacity-slider').addEventListener('input', e => { if(pdfOverlay) pdfOverlay.setOpacity(e.target.value); });
    function showBoundsInfo() { if(pdfOverlay) alert(pdfOverlay.getBounds().toBBoxString()); }

    // --- V15: Street Lights Import & Logic ---
    document.getElementById('sl-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('sl-encoding').value;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                results.data.forEach(row => {
                    const lat = parseFloat(row['y']), lng = parseFloat(row['x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        createStreetLight({
                            name: row['name'],
                            g_code: row['G-code_1st'],
                            lat: lat,
                            lng: lng,
                            origLat: lat,
                            origLng: lng,
                            old_cap: "",
                            new_cap: ""
                        });
                        count++;
                    }
                });
                document.getElementById('sl-status').innerText = `âœ… å·²è¼‰å…¥ ${count} ç­†è·¯ç‡ˆ`;
            }
        });
    });

    function createStreetLight(data) {
        // 1. è—è‰²å®šä½é» (Marker)
        const marker = L.marker([data.lat, data.lng], {
            icon: L.divIcon({className:'drag-point-icon', iconSize:[12,12], bgPos:[0,0]}), // è—é»
            draggable: true
        }).addTo(streetLightsLayer);

        // 2. ç´…è‰²åœ“åœˆ (Circle)
        const circle = L.circle([data.lat, data.lng], {radius: 1, color:'red', weight:2}).addTo(streetLightsLayer);

        // 3. æ–‡å­—æ¨™ç±¤ (Text) - ç¨ç«‹å¯æ‹–æ‹‰
        const textLabel = L.marker([data.lat, data.lng], {
            icon: L.divIcon({ 
                className: 'text-label', 
                html: generateLabelHtml(data.name, data.new_cap), 
                iconSize: [150, 20], iconAnchor: [0, 10]
            }),
            interactive: true, draggable: true
        }).addTo(streetLightsLayer);

        // å„²å­˜é—œè¯
        const slObj = {
            id: Date.now() + Math.random(),
            data: data,
            layers: { marker, circle, textLabel }
        };
        streetLightsData.push(slObj);

        // é€£å‹•é‚è¼¯
        marker.on('drag', e => {
            circle.setLatLng(e.latlng);
            // æ–‡å­—è·Ÿè‘—å‹•ï¼Œä¿æŒç›¸å°ä½ç½® (ç°¡å–®èµ·è¦‹ï¼Œç›´æ¥è·Ÿè‘—å‹•ï¼Œä½¿ç”¨è€…å¯å†å¾®èª¿æ–‡å­—)
            textLabel.setLatLng(e.latlng);
            slObj.data.lat = e.latlng.lat;
            slObj.data.lng = e.latlng.lng;
        });

        // ç·¨è¼¯ Popup
        marker.on('click', () => {
            const content = document.createElement('div');
            content.className = 'sl-popup';
            content.innerHTML = `
                <label>G-code:</label><input type="text" id="edit-gcode" value="${slObj.data.g_code}">
                <label>è®Šæ›´å‰å®¹é‡:</label><input list="list-old-cap" id="edit-old" value="${slObj.data.old_cap}">
                <label>è®Šæ›´å¾Œå®¹é‡(VA):</label><input list="list-new-cap" id="edit-new" value="${slObj.data.new_cap}">
                <button id="btn-save" style="background:#28a745;color:white">ç¢ºèªæ›´æ–°</button>
                <button id="btn-reset" style="background:#17a2b8;color:white">æ¢å¾©åº§æ¨™</button>
            `;
            // Bind Events
            content.querySelector('#btn-save').onclick = () => {
                slObj.data.g_code = content.querySelector('#edit-gcode').value;
                slObj.data.old_cap = content.querySelector('#edit-old').value;
                slObj.data.new_cap = content.querySelector('#edit-new').value;
                // æ›´æ–°æ–‡å­—æ¨™ç±¤
                const newHtml = generateLabelHtml(slObj.data.name, slObj.data.new_cap);
                slObj.layers.textLabel.setIcon(L.divIcon({ 
                    className: 'text-label', html: newHtml, iconSize: [150, 20], iconAnchor: [0, 10]
                }));
                marker.closePopup();
            };
            content.querySelector('#btn-reset').onclick = () => {
                const orig = L.latLng(slObj.data.origLat, slObj.data.origLng);
                marker.setLatLng(orig);
                circle.setLatLng(orig);
                textLabel.setLatLng(orig);
                slObj.data.lat = orig.lat; slObj.data.lng = orig.lng;
                marker.closePopup();
            };
            marker.bindPopup(content).openPopup();
        });
    }

    function generateLabelHtml(name, cap) {
        const text = name + (cap ? (" " + cap) : "");
        return `<div style="color:red;font-size:14px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;">${text}</div>`;
    }

    function clearStreetLights() {
        if(confirm("æ¸…é™¤æ‰€æœ‰è·¯ç‡ˆè³‡æ–™?")) {
            streetLightsLayer.clearLayers();
            streetLightsData = [];
            document.getElementById('sl-status').innerText = "";
        }
    }

    // V15: Export Registration Sheet (CSV)
    window.exportRegistrationSheet = function() {
        if(streetLightsData.length === 0) return alert("ç„¡è·¯ç‡ˆè³‡æ–™");
        
        // Template Columns mapping
        // åºè™Ÿ,è®Šæ›´å‰é›»è™Ÿ,è®Šæ›´å¾Œé›»è™Ÿ,è¡Œæ”¿å€,è£è¨­ä½ç½®æˆ–åœ°å€,è£è¨­åœ°é»åº§æ¨™,è·¯ç‡ˆç·¨è™Ÿ(æ–°),è®Šæ›´å‰ç‡ˆåˆ¥,è®Šæ›´å‰å°å¸³å®¹é‡,è®Šæ›´å‰å°å¸³ç›æ•¸,è®Šæ›´å¾Œç‡ˆåˆ¥,è®Šæ›´å¾Œå®¹é‡(VA),è®Šæ›´å¾Œç›æ•¸,æœå‹™æ‰€,å—ç†è™Ÿç¢¼
        const csvRows = [];
        // Header
        csvRows.push(["åºè™Ÿ","è®Šæ›´å‰é›»è™Ÿ","è®Šæ›´å¾Œé›»è™Ÿ","è¡Œæ”¿å€","è£è¨­ä½ç½®æˆ–åœ°å€","è£è¨­åœ°é»åº§æ¨™","è·¯ç‡ˆç·¨è™Ÿ(æ–°)","è®Šæ›´å‰ç‡ˆåˆ¥","è®Šæ›´å‰å°å¸³å®¹é‡","è®Šæ›´å‰å°å¸³ç›æ•¸","è®Šæ›´å¾Œç‡ˆåˆ¥","è®Šæ›´å¾Œå®¹é‡(VA)","è®Šæ›´å¾Œç›æ•¸","æœå‹™æ‰€","å—ç†è™Ÿç¢¼"]);
        
        streetLightsData.forEach((item, index) => {
            const d = item.data;
            const row = [
                index + 1, // åºè™Ÿ
                "", "", "", "", // å‰å››é …ç•™ç™½
                d.g_code || "", // è£è¨­åœ°é»åº§æ¨™
                d.name || "",   // è·¯ç‡ˆç·¨è™Ÿ(æ–°)
                "",             // è®Šæ›´å‰ç‡ˆåˆ¥
                d.old_cap || "", // è®Šæ›´å‰å°å¸³å®¹é‡
                "",             // è®Šæ›´å‰å°å¸³ç›æ•¸
                "",             // è®Šæ›´å¾Œç‡ˆåˆ¥
                d.new_cap || "", // è®Šæ›´å¾Œå®¹é‡(VA)
                "", "", ""      // å¾Œä¸‰é …ç•™ç™½
            ];
            // è™•ç† CSV é€—è™Ÿèˆ‡å¼•è™Ÿ
            const safeRow = row.map(field => {
                const s = String(field);
                if (s.includes(",") || s.includes('"') || s.includes("\n")) {
                    return `"${s.replace(/"/g, '""')}"`;
                }
                return s;
            });
            csvRows.push(safeRow.join(","));
        });

        const csvContent = "\uFEFF" + csvRows.join("\n"); // BOM for Excel
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement("a");
        const fname = getTimestampedName(currentPdfName + "_ç™»è¨˜å–®", "csv");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        link.click();
    };

    // --- Drawing Tools (Legacy V14) ---
    window.setDrawMode = function(mode) {
        currentDrawMode = mode;
        map.dragging.enable();
        document.querySelectorAll('.draw-tools button').forEach(b => b.classList.remove('active'));
        if(mode) {
            document.getElementById('btn-draw-'+mode).classList.add('active');
            map.dragging.disable(); map.getContainer().style.cursor = 'crosshair';
        } else { map.getContainer().style.cursor = ''; }
    };
    window.clearDrawings = function() { if(confirm("ç¢ºå®šæ¸…é™¤?")) drawnItemsLayer.clearLayers(); };

    function createEditableCircle(latlng, radius, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'circle'; group.color = color;
        const circle = L.circle(latlng, {radius: radius, color: color, weight:2}).addTo(group);
        const handle = L.marker(latlng, {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        handle.on('drag', evt => { circle.setLatLng(evt.latlng); });
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ­¤åœ“</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        handle.bindPopup(popupContent);
        return { group, circle, handle };
    }
    function createEditableLine(latlngs, color) {
        const group = L.layerGroup().addTo(drawnItemsLayer);
        group.drawType = 'line'; group.color = color;
        const line = L.polyline(latlngs, {color: color, weight:3}).addTo(group);
        const h1 = L.marker(latlngs[0], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const h2 = L.marker(latlngs[1], {icon:L.divIcon({className:'drag-point-icon', iconSize:[12,12]}), draggable:true}).addTo(group);
        const updateLine = () => { line.setLatLngs([h1.getLatLng(), h2.getLatLng()]); };
        h1.on('drag', updateLine); h2.on('drag', updateLine);
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ­¤ç·š</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(group); };
        line.bindPopup(popupContent);
        return { group, line };
    }
    function createEditableText(latlng, text, fontSize, color) {
        const marker = L.marker(latlng, {
            icon: L.divIcon({ className: 'text-label', html: `<div style="color:${color};font-size:${fontSize}px;font-weight:bold;text-shadow:1px 1px 0 #fff;white-space:nowrap;line-height:20px;">${text}</div>`, iconSize: [100, 20], iconAnchor: [0, 10] }),
            interactive: true, draggable: true
        }).addTo(drawnItemsLayer);
        marker.drawType = 'text'; marker.textContent = text; marker.fontSize = fontSize; marker.color = color;
        const popupContent = document.createElement('div');
        popupContent.innerHTML = '<button class="delete-btn">åˆªé™¤æ–‡å­—</button>';
        popupContent.querySelector('button').onclick = () => { drawnItemsLayer.removeLayer(marker); };
        marker.bindPopup(popupContent);
        return marker;
    }

    let startPoint = null;
    map.on('mousedown', function(e) {
        if(!currentDrawMode) return;
        startPoint = e.latlng;
        const color = document.getElementById('input-color').value;
        if(currentDrawMode === 'circle') tempDrawShape = L.circle(startPoint, {radius: 1, color:color, weight:2}).addTo(map);
        else if(currentDrawMode === 'line') tempDrawShape = L.polyline([startPoint, startPoint], {color:color, weight:3}).addTo(map);
        else if(currentDrawMode === 'text') {
            const text = prompt("è¼¸å…¥æ–‡å­—:", "è¨»è¨˜");
            if(text) { const fs = document.getElementById('input-font-size').value || 16; createEditableText(startPoint, text, fs, color); }
            setDrawMode(null);
        }
    });
    map.on('mousemove', function(e) {
        if(!currentDrawMode || !startPoint || !tempDrawShape) return;
        if(currentDrawMode === 'circle') tempDrawShape.setRadius(map.distance(startPoint, e.latlng));
        else if(currentDrawMode === 'line') tempDrawShape.setLatLngs([startPoint, e.latlng]);
    });
    map.on('mouseup', function(e) {
        if(!currentDrawMode || !startPoint) return;
        const color = document.getElementById('input-color').value;
        if(tempDrawShape) {
            if(currentDrawMode === 'circle') { const r = tempDrawShape.getRadius(); map.removeLayer(tempDrawShape); createEditableCircle(startPoint, r, color); }
            else if (currentDrawMode === 'line') { const lls = tempDrawShape.getLatLngs(); map.removeLayer(tempDrawShape); createEditableLine(lls, color); }
        }
        startPoint = null; tempDrawShape = null; setDrawMode(null);
    });

    // --- CSV Ref ---
    document.getElementById('ref-csv-input').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const encoding = document.getElementById('csv-encoding').value;
        Papa.parse(file, {
            header: true, encoding: encoding, skipEmptyLines: true,
            complete: function(results) {
                let count = 0;
                results.data.forEach(row => {
                    const lat = parseFloat(row['G-y']), lng = parseFloat(row['G-x']);
                    if (!isNaN(lat) && !isNaN(lng)) {
                        L.circleMarker([lat, lng], { color: 'green', fillColor: '#90EE90', fillOpacity: 0.8, radius: 5 }).bindPopup(`<b>${row['G-code']}</b><br>${row['G-W']||''}`).addTo(refMarkersLayer);
                        count++;
                    }
                });
                document.getElementById('ref-status').innerText = `âœ… å·²è¼‰å…¥ ${count} å€‹`;
            }
        });
    });
    function clearRefMarkers() { refMarkersLayer.clearLayers(); }
    
    // --- Manual Markers ---
    function addMarkerToMap(lat, lng, name, category, id=null) {
        const marker = L.marker([lat, lng], { draggable: true }).addTo(map);
        const dataId = id || Date.now().toString();
        marker.bindPopup(`åç¨±: <input value="${name}" onchange="updateM('${dataId}','name',this.value)"><br>é¡åˆ¥: <select onchange="updateM('${dataId}','category',this.value)"><option value="ä¸€èˆ¬">ä¸€èˆ¬</option><option value="å¾…ä¿®">å¾…ä¿®</option></select><br><button onclick="delM('${dataId}')">åˆªé™¤</button>`);
        markersData.push({ id: dataId, lat, lng, name, category, markerRef: marker });
        marker.on('dragend', e => { const d = markersData.find(x=>x.id===dataId); if(d) { d.lat=e.target.getLatLng().lat; d.lng=e.target.getLatLng().lng; }});
    }
    window.updateM=(id,f,v)=>{const d=markersData.find(x=>x.id===id);if(d)d[f]=v;};
    window.delM=(id)=>{const idx=markersData.findIndex(x=>x.id===id);if(idx>=0){map.removeLayer(markersData[idx].markerRef);markersData.splice(idx,1);}};
    function addManualMarker(){ addMarkerToMap(map.getCenter().lat, map.getCenter().lng, 'æ–°é»', 'ä¸€èˆ¬'); }
    function clearMarkers(){ markersData.forEach(d=>map.removeLayer(d.markerRef)); markersData=[]; }

    // --- Export PDF (Include V15 Street Lights) ---
    async function exportPDF() {
        if (!pdfDocBytes || !pdfOverlay) return alert("è«‹å…ˆä¸Šå‚³ PDF");
        try {
            const { PDFDocument, rgb } = PDFLib;
            const pdfDoc = await PDFDocument.load(pdfDocBytes);
            const page = pdfDoc.getPages()[0];
            const { width: pdfW, height: pdfH } = page.getSize();
            const b = pdfOverlay.getBounds();
            const north = b.getNorth(), south = b.getSouth(), east = b.getEast(), west = b.getWest();

            function toPdfPoint(lat, lng) {
                return { x: ((lng - west)/(east - west))*pdfW, y: ((lat - south)/(north - south))*pdfH };
            }
            const hexToRgb = (hex) => {
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                return rgb(r, g, b);
            }
            async function textToImageBytes(text, fontSize, color) {
                const c = document.getElementById('text-helper-canvas');
                const ctx = c.getContext('2d');
                const scale = 3; const fontStr = `bold ${fontSize * scale}px "Microsoft JhengHei", sans-serif`; 
                ctx.font = fontStr;
                const metrics = ctx.measureText(text);
                const w = Math.ceil(metrics.width); const h = Math.ceil(fontSize * scale * 1.5); 
                c.width = w; c.height = h;
                ctx.font = fontStr; ctx.fillStyle = color; ctx.textBaseline = 'middle';
                ctx.fillText(text, 0, h/2);
                return new Promise(resolve => { c.toBlob(blob => { blob.arrayBuffer().then(resolve); }, 'image/png'); });
            }

            // 1. Street Lights (V15)
            for (const sl of streetLightsData) {
                const lat = sl.layers.circle.getLatLng().lat;
                const lng = sl.layers.circle.getLatLng().lng;
                const pt = toPdfPoint(lat, lng);
                
                // Draw Red Circle
                // Radius approximation
                const edgePt = toPdfPoint(lat + 1/111111, lng);
                const pdfR = Math.abs(edgePt.y - pt.y);
                page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: rgb(1,0,0), borderWidth: 2 });

                // Draw Text (Movable position)
                const textLat = sl.layers.textLabel.getLatLng().lat;
                const textLng = sl.layers.textLabel.getLatLng().lng;
                const txtPt = toPdfPoint(textLat, textLng);
                
                const labelText = sl.data.name + (sl.data.new_cap ? (" " + sl.data.new_cap) : "");
                if(labelText.trim()) {
                    const pngBytes = await textToImageBytes(labelText, 14, '#ff0000');
                    const pngImage = await pdfDoc.embedPng(pngBytes);
                    const dims = pngImage.scale(0.25);
                    page.drawImage(pngImage, { x: txtPt.x, y: txtPt.y - (dims.height/2), width: dims.width, height: dims.height });
                }
            }

            // 2. Manual Markers
            for (const p of markersData) {
                if (p.lat > north || p.lat < south || p.lng > east || p.lng < west) continue;
                const pt = toPdfPoint(p.lat, p.lng);
                page.drawSquare({ x: pt.x - 3, y: pt.y - 3, size: 6, color: rgb(1, 0, 0) });
                const text = (p.name||'') + " " + (p.category||'');
                if(text.trim()) {
                    const pngBytes = await textToImageBytes(text, 12, '#ff0000');
                    const pngImage = await pdfDoc.embedPng(pngBytes);
                    const dims = pngImage.scale(0.25); 
                    page.drawImage(pngImage, { x: pt.x + 5, y: pt.y - (dims.height/2), width: dims.width, height: dims.height });
                }
            }

            // 3. Drawings
            drawnItemsLayer.eachLayer(layer => {
                if (layer.drawType === 'circle') {
                    let circleLayer; layer.eachLayer(l => { if(l instanceof L.Circle) circleLayer = l; });
                    if(circleLayer) {
                        const pt = toPdfPoint(circleLayer.getLatLng().lat, circleLayer.getLatLng().lng);
                        const pdfR = Math.abs(toPdfPoint(circleLayer.getLatLng().lat + circleLayer.getRadius()/111111, circleLayer.getLatLng().lng).y - pt.y);
                        page.drawCircle({ x: pt.x, y: pt.y, size: pdfR, borderColor: hexToRgb(layer.color||'#ff0000'), borderWidth: 2 });
                    }
                } else if (layer.drawType === 'line') {
                    let lineLayer; layer.eachLayer(l => { if(l instanceof L.Polyline) lineLayer = l; });
                    if(lineLayer) {
                        const lls = lineLayer.getLatLngs();
                        const p1 = toPdfPoint(lls[0].lat, lls[0].lng), p2 = toPdfPoint(lls[1].lat, lls[1].lng);
                        page.drawLine({ start: { x: p1.x, y: p1.y }, end: { x: p2.x, y: p2.y }, thickness: 2, color: hexToRgb(layer.color||'#ff0000') });
                    }
                } else if (layer.drawType === 'text') {
                    const pt = toPdfPoint(layer.getLatLng().lat, layer.getLatLng().lng);
                    const fs = parseInt(layer.fontSize || 16);
                    if(layer.textContent) {
                        (async () => {
                            const pngBytes = await textToImageBytes(layer.textContent, fs, layer.color||'#ff0000');
                            const pngImage = await pdfDoc.embedPng(pngBytes);
                            const dims = pngImage.scale(0.25);
                            page.drawImage(pngImage, { x: pt.x, y: pt.y - (dims.height/2), width: dims.width, height: dims.height });
                        })();
                    }
                }
            });
            
            await new Promise(r => setTimeout(r, 800)); // wait for images

            const outBytes = await pdfDoc.save();
            const blob = new Blob([outBytes], { type: 'application/pdf' });
            const link = document.createElement('a');
            const fname = getTimestampedName(currentPdfName, "pdf");
            link.href = URL.createObjectURL(blob);
            link.download = fname;
            document.body.appendChild(link); link.click(); document.body.removeChild(link);
        } catch (err) { console.error(err); alert("åŒ¯å‡ºéŒ¯èª¤ï¼š" + err.message); }
    }

    // --- Save/Load Project (V15: Include Street Lights) ---
    function saveProject() {
        if(!pdfOverlay) return;
        const b = pdfOverlay.getBounds();
        const drawings = [];
        drawnItemsLayer.eachLayer(layer => {
            if(layer.drawType === 'circle') {
                let c; layer.eachLayer(l => { if(l instanceof L.Circle) c = l; });
                if(c) drawings.push({ type: 'circle', lat: c.getLatLng().lat, lng: c.getLatLng().lng, radius: c.getRadius(), color: layer.color });
            } else if(layer.drawType === 'line') {
                let l; layer.eachLayer(line => { if(line instanceof L.Polyline) l = line; });
                if(l) drawings.push({ type: 'line', latlngs: l.getLatLngs(), color: layer.color });
            } else if(layer.drawType === 'text') {
                drawings.push({ type: 'text', lat: layer.getLatLng().lat, lng: layer.getLatLng().lng, content: layer.textContent, fontSize: layer.fontSize, color: layer.color });
            }
        });
        
        // V15: Save Street Light Data
        const sls = streetLightsData.map(sl => {
            return {
                data: sl.data,
                // save positions (might be moved)
                lat: sl.layers.marker.getLatLng().lat,
                lng: sl.layers.marker.getLatLng().lng,
                textLat: sl.layers.textLabel.getLatLng().lat,
                textLng: sl.layers.textLabel.getLatLng().lng
            };
        });

        const data = {
            bounds: { north: b.getNorth(), south: b.getSouth(), east: b.getEast(), west: b.getWest() },
            markers: markersData.map(d => ({ lat:d.lat, lng:d.lng, name:d.name, category:d.category })),
            drawings: drawings,
            streetLights: sls
        };
        const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
        const link = document.createElement('a');
        const fname = getTimestampedName(currentPdfName, "json");
        link.href = URL.createObjectURL(blob);
        link.download = fname;
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }

    function loadProjectClick() { document.getElementById('project-input').click(); }
    document.getElementById('project-input').addEventListener('change', e => {
        const file = e.target.files[0];
        if(!file) return;
        const reader = new FileReader();
        reader.onload = evt => {
            try {
                const d = JSON.parse(evt.target.result);
                if(d.bounds && pdfOverlay) {
                    const b = [[d.bounds.north, d.bounds.west], [d.bounds.south, d.bounds.east]];
                    pdfOverlay.setBounds(b);
                    map.fitBounds(b);
                    if(!isLocked) { clearControlHandles(); createControlHandles(pdfOverlay.getBounds()); }
                }
                if(d.markers) {
                    clearMarkers();
                    d.markers.forEach(p => addMarkerToMap(p.lat, p.lng, p.name, p.category));
                }
                if(d.drawings) {
                    clearDrawings(); 
                    drawnItemsLayer.clearLayers(); 
                    d.drawings.forEach(item => {
                        const color = item.color || '#ff0000';
                        if(item.type === 'circle') createEditableCircle([item.lat, item.lng], item.radius, color);
                        else if(item.type === 'line') createEditableLine(item.latlngs, color);
                        else if(item.type === 'text') createEditableText([item.lat, item.lng], item.content, item.fontSize, color);
                    });
                }
                // V15: Restore Street Lights
                if(d.streetLights) {
                    clearStreetLights();
                    // Bypass confirmation for load
                    streetLightsLayer.clearLayers(); streetLightsData = [];
                    d.streetLights.forEach(item => {
                        createStreetLight(item.data); // Create base
                        // Apply moved positions
                        const sl = streetLightsData[streetLightsData.length-1];
                        const newPt = L.latLng(item.lat, item.lng);
                        sl.layers.marker.setLatLng(newPt);
                        sl.layers.circle.setLatLng(newPt);
                        sl.layers.textLabel.setLatLng([item.textLat, item.textLng]);
                        // Update text content in case it was saved with edits
                        const newHtml = generateLabelHtml(item.data.name, item.data.new_cap);
                        sl.layers.textLabel.setIcon(L.divIcon({ className: 'text-label', html: newHtml, iconSize: [150, 20], iconAnchor: [0, 10] }));
                    });
                    document.getElementById('sl-status').innerText = `âœ… å·²é‚„åŸ ${d.streetLights.length} ç­†è·¯ç‡ˆ`;
                }
            } catch(err) { console.error(err); alert("è®€å–å¤±æ•—"); }
        };
        reader.readAsText(file);
    });
</script>
</body>
</html>
